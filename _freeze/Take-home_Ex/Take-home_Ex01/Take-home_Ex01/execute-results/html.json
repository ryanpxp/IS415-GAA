{
  "hash": "47bdf7273eb03cacf50d96af2539047e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take-home_Ex01\"\nauthor: \"Ryan Peh\"\ndate: \"September 7 30, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n---\n\n\n# **1 Overview**\n\n## **1.1 Objective**\n\nTo apply spatial point patterns analysis methods to discover the spatial and spatio-temporal distribution of armed conflict in Myanmar.\n\n## 1.2 Background\n\n# **2 Setup**\n\n## **2.1 Data**\n\n-   For the purpose of this assignment, armed conflict data of Myanmar between 2021-2024 from [Armed Conflict Location & Event Data (ACLED)](https://acleddata.com/), an independent, impartial, international non-profit organization collecting data on violent conflict and protest in all countries and territories in the world, should be used.\n\n    In terms of event types, students should focus on at least four main event types, namely: Battles, Explosion/Remote violence, Strategic developments, and Violence against civilians.\n\n    In terms of study period, students should focus on quarterly armed conflict events from January 2021 until June 2024.\n\n-   [Geospatial data](http://geonode.themimu.info/layers/?limit=100&offset=0) on [Myanmar Information Management Unit, MIMU](http://www.themimu.info/)\n\n-   Myanmar [OpenStreetMap](https://download.geofabrik.de/asia/myanmar.html)\n\n# **3 The Task**\n\nThe specific tasks of this take-home exercise are as follows:\n\n-   Using appropriate function of **sf** and **tidyverse** packages, import and transform the downloaded armed conflict data and administrative boundary data into sf tibble data.frames.\n\n-   Using the geospatial data sets prepared, derive quarterly KDE layers.\n\n-   Using the geospatial data sets prepared, perform 2nd-Order Spatial Point Patterns Analysis.\n\n-   Using the geospatial data sets prepared, derive quarterly spatio-temporal KDE layers.\n\n-   Using the geospatial data sets prepared, perform 2nd-Order Spatio-temporal Point Patterns Analysis.\n\n-   Using appropriate **tmap** functions, display the KDE and Spatio-temporal KDE layers on openstreetmap of Myanmar.\n\n-   Describe the spatial patterns revealed by the KDE and Spatio-temporal KDE maps.\n\n# **4 Data preparation**\n\n## **4.1 Importing packages**\n\nBefore starting the exercise, we need to import the necessary R packages. The following packages will be used:\n\n-   **tmap**: Used for creating static and interactive visualizations, including summary statistics and KDE layers.\n-   **sf**: Provides a standardized way to encode spatial vector data in the R environment, facilitating spatial data operations and analysis.\n-   **st**: Creates simple features from numeric vectors, matrices, or lists, enabling the representation and manipulation of spatial structures in R.\n-   **spatstat**: A package for statistical analysis of spatial data, particularly for Spatial Point Pattern Analysis. Developed by Baddeley, Turner, and Ruback (2015), it offers a comprehensive set of functions for first- and second-order spatial point pattern analysis and kernel density estimation (KDE).\n-   **tidyverse**: A collection of R packages designed for data science, all sharing a consistent design philosophy, grammar, and data structure.\n-   **raster**: Facilitates reading, writing, manipulating, analyzing, and modeling gridded spatial data (i.e., raster). In this exercise, it will be used to convert image outputs generated by spatstat into raster format.\n-   **lubridate**: Helps to split data into quarters based on their respective years.\n-   **sparr**: A package used for spatial and spatio-temporal kernel density estimation (STKDE). It provides methods for analyzing point patterns in space and time, helping to identify hotspots and spatial clustering over time. In this exercise, it is employed to perform spatio-temporal density analysis using the `spattemp.density` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tmap, sf, tidyverse, raster, spatstat, sp, lubridate, sparr)\n```\n:::\n\n\n## **4.2 Importing datasets**\n\n### **4.2.1 Geospatial Data**\n\nThe following code chunk uses the `st_read()` function from the `sf` package to import the Myanmar shapefile into R. The imported shapefile will be an sf object, representing simple features for spatial analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyanmar_sf <- st_read(dsn = \"data/raw/geospatial\", \n                 layer = \"mmr_polbnda_adm1_250k_mimu_1\")%>%\n  st_transform(crs = 32647)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `mmr_polbnda_adm1_250k_mimu_1' from data source \n  `C:\\ryanpxp\\IS415-GAA\\Take-home_Ex\\Take-home_Ex01\\data\\raw\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 15 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 92.1721 ymin: 9.696844 xmax: 101.17 ymax: 28.54554\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n### **4.2.2 Aspatial Data**\n\nThe dataset obtained from ACLED is in CSV format. To work with this data in R, we need to import it as an sf object using the `st_read()` function from the `sf` package. This function processes the CSV data and produces an sf object for further analysis.\n\nSince we require coordinates and date is not in a useful format to us, we make adjustments accordingly.Moreover, the data has been adjusted to ensure the EPSG coordinates are precise for Myanmar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconflict_sf <- read_csv(\"data/raw/ACLED_Myanmar_2021_2024.csv\") %>%\n  mutate(event_date = dmy(event_date)) %>%\n  st_as_sf(coords = c(\"longitude\", \"latitude\"),\n                       crs = 4326)%>%\n  st_transform(crs = 32647)\n```\n:::\n\n\n### **4.2.3 OpenStreetMap Data**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nosm = st_read(\"data/raw/myanmar-osm.shp.zip\", layer=\"gis_osm_roads_free_1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `gis_osm_roads_free_1' from data source \n  `C:\\ryanpxp\\IS415-GAA\\Take-home_Ex\\Take-home_Ex01\\data\\raw\\myanmar-osm.shp.zip' \n  using driver `ESRI Shapefile'\nSimple feature collection with 569243 features and 10 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 92.13721 ymin: 9.783255 xmax: 101.2285 ymax: 28.37868\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n# **5 Data Wrangling**\n\n## 5.1 KDE\n\n### **5.1.1 Adding columns for quarters**\n\nAdding decimal format of quarters for division of datsets later and quarter formatted string \"YYYYQX\" for presentation. Quarter sequence in the from of numbers 1 to 14 to represent 2021Q1, 2021Q2, ... to 2024Q2 for STKDE analysis later.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconflict_sf <- conflict_sf %>% \n  mutate(DayofYear = yday(event_date)) %>%\n  mutate(Month_num = month(event_date)) %>%\n  mutate(Month_fac = month(event_date, \n                           label = TRUE, \n                           abbr = FALSE)) %>%\n  mutate(Quarter_decimal = quarter(event_date)) %>%\n  mutate(Quarter_label = paste(year(event_date), \"Q\", quarter(event_date), sep = \"\")) %>%\n  mutate(Quarter_sequence = (year(event_date) - 2021) * 4 + quarter(event_date))\n```\n:::\n\n\nRds is written for future readings:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(conflict_sf, \"data/rds/myanmar_conflict.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nconflict_sf <- read_rds(\"data/rds/myanmar_conflict.rds\")\n```\n:::\n\n\nPlot to give a sense of data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(myanmar_sf)+\n  tm_polygons() +\ntm_shape(conflict_sf) +\n  tm_dots() +\ntm_facets(by=\"Quarter_label\", \n            free.coords=FALSE, \n            drop.units = TRUE)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n### **5.1.2 Separating the data by year and quarter**\n\nThe code chunk below separates the data provided into year and quarter for easier plotting.\n\nA list is created to store the filtered data by year and quarter and is flatten to change from a list of 4 items with another 4 nested items each to a list of 16 items. Names were then assigned to these items in the list so that it will be more intuitive to retrieve the required sf than just calling a number.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define years and quarters\nyears <- 2021:2024\nquarters <- 1:4\n\n# Create a list to store the filtered data\nconflict_list <- map(years, function(yr) {\n  map(quarters, function(qtr) {\n    conflict_sf %>%\n      filter(year == yr, Quarter_decimal == qtr)\n  })\n})%>%\n  flatten() # Flatten the list to remove nested structure\n\n# give names to the list items\nnames(conflict_list) <- map(years, function(yr) {\n  map(quarters, function(qtr) {\n    paste0(\"conflict_\", yr, \".Q\", qtr, \"_sf\")\n  })\n}) %>%\n  unlist() # Unlist to match the flattened structure\n\n# Remove specific problematic entries for 2024 Q3 and Q4\nconflict_list <- conflict_list[!names(conflict_list) %in% c(\"conflict_2024.Q3_sf\", \"conflict_2024.Q4_sf\")]\n```\n:::\n\n\nIn order to read the sf of 2021 q1:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconflict_list[[\"conflict_2021.Q1_sf\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 4843 features and 32 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -203795.3 ymin: 1103500 xmax: 591875.9 ymax: 3042960\nProjected CRS: WGS 84 / UTM zone 47N\n# A tibble: 4,843 × 33\n   event_id_cnty event_date  year time_precision disorder_type        event_type\n * <chr>         <date>     <dbl>          <dbl> <chr>                <chr>     \n 1 MMR14614      2021-03-31  2021              1 Political violence   Explosion…\n 2 MMR14614      2021-03-31  2021              1 Political violence   Explosion…\n 3 MMR14632      2021-03-31  2021              1 Strategic developme… Strategic…\n 4 MMR14632      2021-03-31  2021              1 Strategic developme… Strategic…\n 5 MMR14625      2021-03-31  2021              1 Political violence   Battles   \n 6 MMR14625      2021-03-31  2021              1 Political violence   Battles   \n 7 MMR14609      2021-03-31  2021              1 Political violence   Violence …\n 8 MMR14609      2021-03-31  2021              1 Political violence   Violence …\n 9 MMR14618      2021-03-31  2021              1 Strategic developme… Strategic…\n10 MMR14653      2021-03-31  2021              1 Political violence   Violence …\n# ℹ 4,833 more rows\n# ℹ 27 more variables: sub_event_type <chr>, actor1 <chr>, assoc_actor_1 <chr>,\n#   inter1 <dbl>, interaction <dbl>, civilian_targeting <chr>, iso <dbl>,\n#   region <chr>, country <chr>, admin1 <chr>, admin2 <chr>, admin3 <chr>,\n#   location <chr>, geo_precision <dbl>, source <chr>, source_scale <chr>,\n#   notes <chr>, fatalities <dbl>, tags <chr>, timestamp <dbl>,\n#   geometry <POINT [m]>, DayofYear <dbl>, Month_num <dbl>, Month_fac <ord>, …\n```\n\n\n:::\n:::\n\n\n### **5.1.3 Converting sf data frames to sp’s Spatial\\* class**\n\nThe code chunk below uses [*as_Spatial()*](https://r4gdsa.netlify.app/chap04.html?q=KDE%20layers) of **sf** package to convert the geospatial data from simple feature data frame to sp’s Spatial\\* class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Overall\nconflict_sp <- as_Spatial(conflict_sf)\n\n# Convert all sf objects to Spatial objects using map\nconflict_sp_list <- map(conflict_list, as_Spatial)\n\n# Give meaningful names to the list elements\nnames(conflict_sp_list) <- c(\n  \"conflict_2021.Q1\", \"conflict_2021.Q2\", \"conflict_2021.Q3\", \"conflict_2021.Q4\",\n  \"conflict_2022.Q1\", \"conflict_2022.Q2\", \"conflict_2022.Q3\", \"conflict_2022.Q4\",\n  \"conflict_2023.Q1\", \"conflict_2023.Q2\", \"conflict_2023.Q3\", \"conflict_2023.Q4\",\n  \"conflict_2024.Q1\", \"conflict_2024.Q2\"\n)\n```\n:::\n\n\nIn order to read 2021 q1:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconflict_sp_list[[\"conflict_2021.Q1\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatialPointsDataFrame \nfeatures    : 4843 \nextent      : -203795.3, 591875.9, 1103500, 3042960  (xmin, xmax, ymin, ymax)\ncrs         : +proj=utm +zone=47 +datum=WGS84 +units=m +no_defs \nvariables   : 32\nnames       : event_id_cnty, event_date, year, time_precision,          disorder_type,                 event_type,                 sub_event_type,                                     actor1,                                                                                                     assoc_actor_1, inter1, interaction, civilian_targeting, iso,         region, country, ... \nmin values  :      MMR10890,      18628, 2021,              1,         Demonstrations,                    Battles, Abduction/forced disappearance,       ARSA: Arakan Rohingya Salvation Army, 88 Generation Peace and Open Society; Buddhist Group (Myanmar); Government of Myanmar (2016-); Students (Myanmar),      1,          10, Civilian targeting, 104, Southeast Asia, Myanmar, ... \nmax values  :      MMR62411,      18717, 2021,              3, Strategic developments, Violence against civilians,          Violent demonstration, YURF: Yadanarbon Urban Revolutionary Front,                                                                  Women (Myanmar); Rohingya Muslim Group (Myanmar),      7,          70, Civilian targeting, 104, Southeast Asia, Myanmar, ... \n```\n\n\n:::\n:::\n\n\n### **5.1.4 Converting the simple features to spatstat’s ppp (planar point pattern) object**\n\n**spatstat** requires the analytical data in ***ppp*** object form. Hence we will convert `sf` objects to `ppp` objects using **as.ppp()** function by providing the point coordinates and the observation window.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# overall\nconflict_ppp <- as.ppp(st_coordinates(conflict_sf), st_bbox(conflict_sf))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: data contain duplicated points\n```\n\n\n:::\n\n```{.r .cell-code}\n# Create names for the resulting ppp objects\nppp_names <- paste0(rep(years, each = 4), \".Q\", rep(quarters, length(years)))\n# Remove the last two names (2024q3 and 2024q4)\nppp_names <- ppp_names[1:(length(ppp_names) - 2)]\n\n# Apply the conversion using map2 from purrr and assign the results dynamically\nconflict_ppp_list <- map(conflict_list, ~ as.ppp(st_coordinates(.x), st_bbox(.x)))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: data contain duplicated points\nWarning: data contain duplicated points\nWarning: data contain duplicated points\nWarning: data contain duplicated points\nWarning: data contain duplicated points\nWarning: data contain duplicated points\nWarning: data contain duplicated points\nWarning: data contain duplicated points\nWarning: data contain duplicated points\nWarning: data contain duplicated points\nWarning: data contain duplicated points\nWarning: data contain duplicated points\nWarning: data contain duplicated points\nWarning: data contain duplicated points\n```\n\n\n:::\n\n```{.r .cell-code}\n# Assign names to the ppp list\nnames(conflict_ppp_list) <- ppp_names\n```\n:::\n\n\nQuick look at the new ppp object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(conflict_ppp_list[[\"2021.Q2\"]], main = \"2021.Q2\")\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nThe summary statistics of a newly created ppp object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(conflict_ppp_list[[\"2021.Q2\"]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPlanar point pattern:  7017 points\nAverage intensity 4.412701e-09 points per square unit\n\n*Pattern contains duplicated points*\n\nCoordinates are given to 13 decimal places\n\nWindow: rectangle = [-191409.1, 640934.5] x [1132472.1, 3042960.3] units\n                    (832300 x 1910000 units)\nWindow area = 1.59018e+12 square units\n```\n\n\n:::\n:::\n\n\n### **5.1.5 Handling duplicated points**\n\nIt is previously mentioned in `summary(acled_ppp)` that there are duplicated points in the patterns. Duplication in ***ppp*** object can be confirmed by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany(duplicated(conflict_ppp_list[[\"2021.Q2\"]]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nWe can address this by using `rjitter()` which will add a small perturbation to the duplicate points so that they do not occupy the exact same spaces.\n\nA function was declared to apply `rjitter()` to all the items in the list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# overall\nconflict_ppp_jit <- rjitter(conflict_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\n\n# Define a function to apply rjitter to each ppp object\njitter_conflict_ppp_func <- function(ppp) {\n  rjitter(ppp, retry = TRUE, nsim = 1, drop = TRUE)\n}\n\n# Apply jittering to all ppp objects\njittered_ppp_list <- map(conflict_ppp_list, jitter_conflict_ppp_func)\n```\n:::\n\n\nConfirm if there is still any duplicate points:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany(duplicated(jittered_ppp_list[[\"2021.Q1\"]]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n### **5.1.6 Creating *owin* object**\n\nConversion of the `myanmar_sf` object into an `owin` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyanmar_owin <- as.owin(myanmar_sf)\nplot(myanmar_owin)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(myanmar_owin)\n```\n:::\n\n\n### **5.1.7 Creating point events objects in *owin* Object**\n\nCreate point events in *owin* Object after jittering the duplications.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# overall\nconflictmyanmar_ppp = conflict_ppp_jit[myanmar_owin]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a function to merge ppp and owin object\nmerge_ppp_owin_func <- function(ppp, owin) {\n  ppp[owin]\n}\n\nconflictmyanmar_ppp_list <- map(jittered_ppp_list, ~ merge_ppp_owin_func(.x, myanmar_owin))\n```\n:::\n\n\nObject combines both the point and polygon feature in one `ppp` object class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(conflictmyanmar_ppp_list[[\"2021.Q1\"]])\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(conflictmyanmar_ppp_list[[\"2021.Q1\"]], main = \"Myanmar Q1 2021\")\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n## 5.2 STKDE\n\n### **5.2.1 Extracting the data by quarter**\n\nTo prepare the **sf** object for STKDE, the Quarter_sequence was extracted from the **sf** object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconflict_quarterly <- conflict_sf %>% \n  dplyr::select(Quarter_sequence)\n```\n:::\n\n\n### **5.2.2 Converting the simple features to spatstat’s ppp object**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconflict_quarterly_ppp <- as.ppp(conflict_quarterly)\n```\n:::\n\n\n### **5.2.3 Handling duplicated points**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany(duplicated(conflict_quarterly_ppp))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nConfirmation of the existence of duplicates, use `rjitter()`to remove duplicates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconflict_quarterly_ppp <- rjitter(conflict_quarterly_ppp, retry = TRUE, nsimm = 1, drop = TRUE)\nany(duplicated(conflict_quarterly_ppp))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n### **5.2.4 Creating point events objects in *owin* Object**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconflict_quarterly_Map_ppp = conflict_quarterly_ppp[myanmar_owin]\n#summary(conflict_quarterly_Map_ppp)\n```\n:::\n\n\n## **5.3 OpenStreetMap**\n\nSince the file is quite large we should try to reduce the size of the file\n\n### **5.3.1 Data clean up**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(osm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"osm_id\"   \"code\"     \"fclass\"   \"name\"     \"ref\"      \"oneway\"  \n [7] \"maxspeed\" \"layer\"    \"bridge\"   \"tunnel\"   \"geometry\"\n```\n\n\n:::\n:::\n\n\nLooking at the headers, fclass seems interesting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(osm$fclass)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"primary\"        \"secondary\"      \"unclassified\"   \"residential\"   \n [5] \"trunk_link\"     \"primary_link\"   \"tertiary\"       \"service\"       \n [9] \"footway\"        \"track\"          \"trunk\"          \"path\"          \n[13] \"living_street\"  \"track_grade4\"   \"secondary_link\" \"unknown\"       \n[17] \"track_grade5\"   \"motorway\"       \"steps\"          \"track_grade2\"  \n[21] \"track_grade1\"   \"track_grade3\"   \"tertiary_link\"  \"motorway_link\" \n[25] \"pedestrian\"     \"cycleway\"       \"bridleway\"     \n```\n\n\n:::\n:::\n\n\nWe will keep these fclasses: \"primary\", \"secondary\", \"residential\", \"trunk_link\", \"primary_link\", \"tertiary\", \"footway\", \"trunk\", \"secondary_link\", \"tertiary_link\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfclasses <- c(\"primary\", \"secondary\", \"residential\", \"trunk_link\", \"primary_link\", \"tertiary\", \"footway\", \"trunk\", \"secondary_link\", \"tertiary_link\")\n\nosm <- osm[osm$fclass %in% fclasses, ]\n```\n:::\n\n\nTo further reduce the size, we keep only osm_id and fclass\n\n\n::: {.cell}\n\n```{.r .cell-code}\nosm <- osm %>% dplyr::select('osm_id', 'fclass')\n```\n:::\n\n\nWe also have to transform the crs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nosm <- st_transform(osm, crs = 32647)\n```\n:::\n\n\n### **5.3.2 Merging osm and sf**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmerged_myanmar <- st_union(myanmar_sf)\nosm_myanmar <- st_intersection(osm, merged_myanmar)\n```\n:::\n\nRds is written for future readings:\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(osm_myanmar, \"data/rds/osm_myanmar.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nosm_myanmar <- read_rds(\"data/rds/osm_myanmar.rds\")\n```\n:::\n\n\nSome geometries in the `osm` dataset are stored as `MULTILINESTRING`, which may cause issues during KDE calculations. To address this, we will split them into individual `LINESTRING` geometries.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nosm_myanmar <- st_cast(st_cast(osm_myanmar, \"MULTILINESTRING\"),\"LINESTRING\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in st_cast.sf(st_cast(osm_myanmar, \"MULTILINESTRING\"), \"LINESTRING\"):\nrepeating attributes for all sub-geometries for which they may not be constant\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(osm_myanmar)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    osm_id             fclass                   geometry     \n Length:273089      Length:273089      LINESTRING   :273089  \n Class :character   Class :character   epsg:32647   :     0  \n Mode  :character   Mode  :character   +proj=utm ...:     0  \n```\n\n\n:::\n:::\n\n\n# **6 First-order Spatial Point Patterns Analysis**\n\n## **6.1 Kernel Density Estimation**\n\n### **6.1.1 Rescaling KDE Layers**\n\nSince the distance is in meters we have to use `rescale()` function of **spatstat** package to covert the unit of measurement from meter to kilometer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# overall\nconflictmyanmar_ppp.km <- rescale(conflictmyanmar_ppp, 1000, \"km\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a function covert the unit of measurement from meter to kilometer\nrescale_km_func <- function(ppp) {\n  rescale(ppp, 1000, \"km\")\n}\n\nconflictmyanmar_ppp_km_list <- map(conflictmyanmar_ppp_list, rescale_km_func)\n```\n:::\n\n\n### 6.1.2 Quarterly KDE layers\n\nTo have a understanding of what the value of sigma to use for the KDE layer, we plot using sigma value of 10, 25, 50, 100 on 2021 Q1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyanmar_conflict_quarterly_Map_bw10 <- density(conflictmyanmar_ppp_km_list[[\"2021.Q1\"]], sigma = 10, edge = TRUE, kernel = \"gaussian\")\nmyanmar_conflict_quarterly_Map_bw25 <- density(conflictmyanmar_ppp_km_list[[\"2021.Q1\"]], sigma = 25, edge = TRUE, kernel = \"gaussian\")\nmyanmar_conflict_quarterly_Map_bw50 <- density(conflictmyanmar_ppp_km_list[[\"2021.Q1\"]], sigma = 50, edge = TRUE, kernel = \"gaussian\")\nmyanmar_conflict_quarterly_Map_bw100 <- density(conflictmyanmar_ppp_km_list[[\"2021.Q1\"]], sigma = 100, edge = TRUE, kernel = \"gaussian\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(2,2))\npar(mar = c(3,2,2,1))\nplot(myanmar_conflict_quarterly_Map_bw10, main = \"10\")\nplot(myanmar_conflict_quarterly_Map_bw25, main = \"25\")\nplot(myanmar_conflict_quarterly_Map_bw50, main = \"50\")\nplot(myanmar_conflict_quarterly_Map_bw100, main = \"100\")\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-42-1.png){width=672}\n:::\n:::\n\n\nFrom the plot, sigma value of 50 looks like a good representation.\n\nNow we plot the graphs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define get kde\nrescale_km_func <- function(pppkm) {\n  density(pppkm,\n          sigma=50, \n          edge=TRUE, \n          kernel=\"gaussian\")\n}\n\nkde_conflictmyanmar_list <- map(conflictmyanmar_ppp_km_list, rescale_km_func)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfcol=c(2,2), \n    mar=c(1, 1, 2, 1),\n    cex.axis=0.7,        \n    cex.main=0.8) \nfor (quarter in names(kde_conflictmyanmar_list)) {\n  plot(kde_conflictmyanmar_list[[quarter]], main = quarter)\n}\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-44-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-44-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-44-4.png){width=672}\n:::\n:::\n\n\n\n### 6.1.3 Quarterly spatio-temporal KDE layers\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconflict_quarterly_Map_ppp = rescale(conflict_quarterly_Map_ppp, 1000, \"km\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(conflict_quarterly_Map_ppp)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-46-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nst_kde <- spattemp.density(conflict_quarterly_Map_ppp)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCalculating trivariate smooth...Done.\nEdge-correcting...Done.\nConditioning on time...Done.\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(st_kde)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatiotemporal Kernel Density Estimate\n\nBandwidths\n  h = 39.5528 (spatial)\n  lambda = 0.0031 (temporal)\n\nNo. of observations\n  87644 \n\nSpatial bound\n  Type: polygonal\n  2D enclosure: [-210.0086, 724.6476] x [1072.026, 3158.467]\n\nTemporal bound\n  [1, 14]\n\nEvaluation\n  128 x 128 x 14 trivariate lattice\n  Density range: [1.024509e-21, 0.0003297299]\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1 to 14 for each quarter\ntims <- c(1:14)\npar(mfcol=c(2,2), \n    mar=c(1, 1, 2, 1),\n    cex.axis=0.7,        \n    cex.main=0.8)\n\n# function to map tims to \"Year QQuarter\"\nget_quarter_label <- function(i) {\n  year <- 2021 + (i - 1) %/% 4  # Calculate the year\n  quarter <- (i - 1) %% 4 + 1   # Calculate the quarter (1 to 4)\n  return(paste(year, \"Q\", quarter, sep = \"\"))\n}\n\nfor(i in tims){ \n  plot(st_kde, i, \n       override.par=FALSE, \n       fix.range=TRUE, \n       main=get_quarter_label(i))\n}\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-48-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-48-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-48-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-48-4.png){width=672}\n:::\n:::\n\n\n### 6.1.4 OpenStreetMap\n\n\n::: {.cell}\n\n```{.r .cell-code}\nosm_density <- density(conflictmyanmar_ppp_km_list[[\"2021.Q4\"]], \n             sigma=50, \n             edge=TRUE, \n             kernel=\"gaussian\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndensity_raster <- raster(osm_density)\nprojection(density_raster) <- CRS(\"+init=EPSG:32647\")\nplot(osm_myanmar)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-50-1.png){width=672}\n:::\n:::\n\n\n### 6.1.5 Interpretations\n\nFrom the KDE and STKDE plots, the area around Mandalay, Sagaing, Kachin and Magway has a concentration of conflicts. The regions of Bago and Yangon also have some indications of clusters of conflicts.\n\n# 7 Second-order analysis\n\nAfter looking at the quarterly KDE layers these three areas have the highest amount of conflicts occurring in the Dry Zones: Magway, Sagaing, Mandalay.\n\nThe aims of conflict actors in the Dry Zone are relatively straightforward: [to sustain the coup or overturn it](https://myanmar.iiss.org/analysis/dryzone).\n\nSagaing Region has emerged as a [stronghold of resistance to military rule](https://www.frontiermyanmar.net/en/conflicts-deepen-between-resistance-groups-in-sagaing/) plagued by factionalism and in-fighting.\n\nWe will focus on these areas to understand the distributions of the conflicts instead of all the regions.\n\n## **7.1 Second-order analysis Data Wrangling**\n\n#### 7.1.1 Study areas filtering\n\nThe code chunk below targets the three areas mentioned previously.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMW <- myanmar_sf %>%\n  filter(ST == \"Magway\")\nSGI <- myanmar_sf %>%\n  filter(ST == \"Sagaing\")\nMDL <- myanmar_sf %>%\n  filter(ST == \"Mandalay\")\n```\n:::\n\n\n#### 7.1.2 Converting sf objects into ***owin*** objects\n\n**Spatstat** requires the conversion of these sf objects into owin objects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMW_owin <- as.owin(MW)\nSGI_owin <- as.owin(SGI)\nMDL_owin <- as.owin(MDL)\n```\n:::\n\n\n#### 7.1.3 Creating event points\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMW_ppp = conflict_ppp_jit[MW_owin]\nSGI_ppp = conflict_ppp_jit[SGI_owin]\nMDL_ppp = conflict_ppp_jit[MDL_owin]\n```\n:::\n\n\n`rescale()` to transform from meters to kilometers for its distance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMW_ppp.km = rescale(MW_ppp, 1000, \"km\")\nSGI_ppp.km = rescale(SGI_ppp, 1000, \"km\")\nMDL_ppp.km = rescale(MDL_ppp, 1000, \"km\")\n```\n:::\n\n\nThe three area of interests are as shown:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(2,2))\npar(mar = c(3,2,2,1))\nplot(MW_ppp.km, main=\"Magway\")\nplot(SGI_ppp.km, main=\"Sagaing\")\nplot(MDL_ppp.km, main=\"Mandalay\")\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-55-1.png){width=672}\n:::\n:::\n\n\n## **7.2 G-Function for Spatial Point Process Analysis**\n\nWe use G-function to determine if conflicts are occurring closer together than would be expected under random conditions, indicating potential hot spots.\n\n### 7.2.1 Magway area\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_MW = Gest(MW_ppp, correction = \"rs\")\nplot(G_MW, xlim=c(0,50))\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-56-1.png){width=672}\n:::\n:::\n\n\nTo confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:\n\nHo = The distribution of events in Magway are randomly distributed.\n\nH1= The distribution of events in Magway are not randomly distributed.\n\nThe null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.\n\nMonte Carlo test with G-function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_MW.csr <- envelope(MW_ppp, Gest, nsim = 249)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGenerating 249 simulations of CSR  ...\n1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34\n.36.38.40.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74\n.76.78.80.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114\n.116.118.120.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154\n.156.158.160.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194\n.196.198.200.202.204.206.208.210.212.214.216.218.220.222.224.226.228.230.232.234\n.236.238.240.242.244.246.248\n249.\n\nDone.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(G_MW.csr)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-58-1.png){width=672}\n:::\n:::\n\n\n### 7.2.2 Sagaing area\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_SGI = Gest(SGI_ppp, correction = \"border\")\nplot(G_SGI, xlim=c(0,50))\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-59-1.png){width=672}\n:::\n:::\n\n\nTo confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:\n\nHo = The distribution of events in Sagaing are randomly distributed.\n\nH1= The distribution of events in Sagaing are not randomly distributed.\n\nThe null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.\n\nMonte Carlo test with G-function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_SGI.csr <- envelope(SGI_ppp, Gest, nsim = 249)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGenerating 249 simulations of CSR  ...\n1, 2,  [4:05 remaining] 3, 4 [4:04 remaining] .6 [4:03 remaining] .8\n [4:02 remaining] .10 [4:03 remaining] .12 [4:13 remaining] .14 [4:23 remaining] .\n16 [4:21 remaining] .18 [4:20 remaining] .20 [4:18 remaining] .22\n [4:18 remaining] .24 [4:13 remaining] .26 [4:08 remaining] .28 [4:05 remaining] .\n30 [4:01 remaining] .32 [3:57 remaining] .34 [3:54 remaining] .36\n [3:51 remaining] .38 [3:48 remaining] .40 [3:47 remaining] .42 [3:44 remaining] .\n44 [3:42 remaining] .46 [3:39 remaining] .48 [3:36 remaining] .50\n [3:34 remaining] .52 [3:33 remaining] .54 [3:32 remaining] .56 [3:30 remaining] .\n58 [3:27 remaining] .60 [3:25 remaining] .62 [3:23 remaining] .64\n [3:20 remaining] .66 [3:18 remaining] .68 [3:15 remaining] .70 [3:13 remaining] .\n72 [3:11 remaining] .74 [3:09 remaining] .76 [3:06 remaining] .78\n [3:04 remaining] .80 [3:01 remaining] .82 [2:59 remaining] .84 [2:57 remaining] .\n86 [2:55 remaining] .88 [2:52 remaining] .90 [2:50 remaining] .92\n [2:48 remaining] .94 [2:47 remaining] .96 [2:45 remaining] .98 [2:43 remaining] .\n100 [2:40 remaining] .102 [2:38 remaining] .104 [2:36 remaining] .106\n [2:33 remaining] .108 [2:31 remaining] .110 [2:29 remaining] .112 [2:26 remaining] .\n114 [2:24 remaining] .116 [2:22 remaining] .118 [2:19 remaining] .120\n [2:17 remaining] .122 [2:16 remaining] .124 [2:14 remaining] .126 [2:12 remaining] .\n128 [2:10 remaining] .130 [2:08 remaining] .132 [2:06 remaining] .134\n [2:03 remaining] .136 [2:01 remaining] .138 [1:59 remaining] .140 [1:57 remaining] .\n142 [1:55 remaining] .144 [1:53 remaining] .146 [1:51 remaining] .148\n [1:50 remaining] .150 [1:47 remaining] .152 [1:45 remaining] .154 [1:43 remaining] .\n156 [1:41 remaining] .158 [1:38 remaining] .160 [1:36 remaining] .162\n [1:34 remaining] .164 [1:31 remaining] .166 [1:29 remaining] .168 [1:27 remaining] .\n170 [1:25 remaining] .172 [1:22 remaining] .174 [1:20 remaining] .176\n [1:18 remaining] .178 [1:16 remaining] .180 [1:14 remaining] .182 [1:11 remaining] .\n184 [1:09 remaining] .186 [1:07 remaining] .188 [1:05 remaining] .190\n [1:03 remaining] .192 [1:01 remaining] .194 [58 sec remaining] .196 [56 sec remaining] .\n198 [54 sec remaining] .200 [52 sec remaining] .202 [50 sec remaining] .204\n [48 sec remaining] .206 [46 sec remaining] .208 [44 sec remaining] .210 [42 sec remaining] .\n212 [40 sec remaining] .214 [37 sec remaining] .216 [35 sec remaining] .218\n [33 sec remaining] .220 [31 sec remaining] .222 [29 sec remaining] .224 [27 sec remaining] .\n226 [25 sec remaining] .228 [22 sec remaining] .230 [20 sec remaining] .232\n [18 sec remaining] .234 [16 sec remaining] .236 [14 sec remaining] .238 [12 sec remaining] .\n240 [10 sec remaining] .242 [8 sec remaining] .244 [5 sec remaining] .246\n [3 sec remaining] .248 [1 sec remaining] \n249.\n\nDone.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(G_SGI.csr)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-61-1.png){width=672}\n:::\n:::\n\n\n### 7.2.3 Mandalay area\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_MDL = Gest(MDL_ppp, correction = \"border\")\nplot(G_MDL, xlim=c(0,50))\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-62-1.png){width=672}\n:::\n:::\n\n\nTo confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:\n\nHo = The distribution of events in Mandalay are randomly distributed.\n\nH1= The distribution of events in Mandalay are not randomly distributed.\n\nThe null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.\n\nMonte Carlo test with G-function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG_MDL.csr <- envelope(MDL_ppp, Gest, nsim = 249)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGenerating 249 simulations of CSR  ...\n1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34\n.36.38.40.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74\n.76.78.80.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114\n.116.118.120.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154\n.156.158.160.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194\n.196.198.200.202.204.206.208.210.212.214.216.218.220.222.224.226.228.230.232.234\n.236.238.240.242.244.246.248\n249.\n\nDone.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(G_MDL.csr)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-64-1.png){width=672}\n:::\n:::\n\n\n### 7.2.4 Interpretation of G-Function\n\nThe observed G-function (solid line) deviates significantly from the theoretical and envelope lines, rising sharply and reaching a higher value.\n\nThis deviation suggests that the events in the three regions are not randomly distributed. The observed pattern shows clustering or aggregation of events at shorter distances. Given the sharp rise and high values of the observed function compared to the theoretical expectations, it's likely that the null hypothesis will be rejected, indicating that the distribution of events in three regions is significantly different from a random spatial distribution.\n\nThe analysis suggests the presence of spatial autocorrelation or clustering in the three regions area, which could be important for understanding the underlying spatial processes or patterns in the region.\n\n# 8 Conclusion\n\nThe spatial analysis of conflict events in Myanmar reveals significant clustering patterns, particularly when comparing the observed G-function with theoretical expectations. The observed G-function deviates sharply from the theoretical and envelope lines, suggesting that conflict events are not randomly distributed but instead show a tendency to cluster at shorter distances. This pattern indicates spatial autocorrelation, and the null hypothesis of random distribution is likely to be rejected.\n\nFurther insights from KDE and STKDE plots highlight concentrated conflict zones around Mandalay, Sagaing, Kachin, and Magway. Additionally, regions like Bago and Yangon show indications of conflict clusters. These findings suggest that specific regions in Myanmar experience more frequent or intense conflict activity, underscoring the need to explore underlying causes of spatial clustering in these areas. This clustering could be crucial for understanding the broader spatial processes driving conflict in the country.\n\nThis study's identification of conflict clusters across regions in Myanmar, particularly in areas like Mandalay, Sagaing, Kachin, Magway, Bago, and Yangon, should provides critical insights into the spatial dynamics of conflict. Understanding where and how these conflicts concentrate can inform targeted peace building efforts, helping policymakers and organizations focus resources on the most affected areas. By addressing the root causes of conflict in these regions, this spatial analysis can play a pivotal role in fostering dialogue, promoting stability, and ultimately contributing to a more peaceful resolution of ongoing tensions in Myanmar.\n",
    "supporting": [
      "Take-home_Ex01_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}